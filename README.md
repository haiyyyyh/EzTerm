# EzTerm(持续维护中)

## 简介

### 为什么要做EzTerm

我在使用了一段时间**NCurses**之后, 发现对现代终端模拟器和PC键盘的支持不佳, 从某些方面来讲, 存在较重历史包袱, 于是产生了自己编写终端库的想法, 旨在替代历史包袱较重的NCurses, 并更进一步了解类Unix系统的终端

### 特色

不同于其他现代终端库的高度抽象和封装

> 如python华丽的终端文本界面库`textual`,  go的`bubble tea`,`termui`

**EzTerm** 保留了类curses终端库的风格, 使用各种函数, 允许用户精确绘制每一个字符  
**EzTerm** 源码单文件, 代码扁平化, 注重轻封装, 易于阅读

## 介绍

*类Unix系统*的终端有一套标准, 通过向终端输出特定的ANSI转义序列, 可以设置输出文本的颜色和风格, 移动光标, 还有各种各样的操作  
而终端库, 本质就是封装**ANSI序列**和**系统调用** 实现的  
> ANSI序列: 以\033(也就是ESC)开头, 字母结尾的序列, 能被终端识别并产生效果, 是一种终端的"特殊语言"

### 原理

#### 不同于**NCurses**
NCurses使用"窗口"结构体, 这是一个大型的容器, 记录了它自己上面所有字符的属性, 还包括*脏块标记*, 和窗口自己的信息, 大部分函数都是对"窗口"进行操作, 每次刷新由`refresh()`,`wrefresh()`函数扫描整个窗口, 它们会识别 **标记为"脏"** 的区域, 然后还会根据环境 (比如不同终端模拟器 个别序列可能不通用) 生成出一大长串东西, 包含 **ANSI转义序列** 和 **字符**, 然后将这一大串打到终端上
> 优点: 兼容性好, NCurses要适配不同的终端, 包括历史上很多老旧的终端机, 并且将碎片化IO变成大型低频IO, 减小频繁进行write系统调用的开销  

> 缺点: 历史包袱较重, 代码复杂, 频繁刷新的开销极大

**EzTerm** 则使用了轻量的字符流缓冲区, 刷新时将缓冲区(字符数组)通过`write()`系统调用写入到 stdout , 同样实现了碎片化IO的合并  
而 **EzTerm** 的所有函数 比如`printstr()`,`curs_()`,`screen_()`,`attrset_()`系函数, 直接对应**ANSI序列**, 将其写入到字符流缓冲区中  

## 说明

如果你也喜欢TUI, 爱在终端里干各种事情, 并且对TUI应用程序 比如vim,neovim 很有兴趣, 想要深入了解, 那么**EzTerm**可以说不容错过

- **EzTerm**用到的所有转义序列, 包括功能键的序列, 都是我通过查文档和实验得到的, 比较标准 且现代终端模拟器支持良好, 你便不需要经历像我一样到处查文档 最后被标准弄晕 的痛苦过程了

- **EzTerm**的源码十分清晰(我自己觉得), 头文件里也有对每个函数的注释, 我希望**EzTerm**的源码和头文件本身, 就能当作 终端操作/**EzTerm**使用方法 的终极文档, 最详细, 最贴近现实, 所有东西都和EzTerm实际的行为一一对应

### 源码结构

```sh
 EzTerm
│
├──  .clangd  # clangd C++的LSP服务器的配置文件
│
├──  .vscode
│   └──  launch.json
│
├──  bin  # 编译出的二进制
│   ├──  libezterm.a  # 静态链接库
│   └──  libezterm.so  # 动态链接库
│
├── 󱧼 build  # 不用管, 一些临时文件
│   ├──  ezterm.d
│   ├──  ezterm.ii
│   ├──  ezterm.o
│   └──  ezterm.s
│
├──  doc  # 文档,后续可能会向里面加一些说明性质的东西
│   └──  KEY.md  # 关于 键盘功能键序列 的说明
│
├──  include  # 头文件
│   └──  ezterm.h
│
├──  Makefile  # 构建文件
│
├── 󰂺 README.md  # 本文
│
├── 󰣞 src  # 核心:源代码
│   └──  ezterm.cpp
│
└──  test  # 我自己开发过程的测试文件, just for fun
    ├──  bit.cpp  # 模拟一个16位无符号整形溢出的过程(EzTerm和NCurses性能测试)
    ├──  Color_test.cpp  # 颜色功能测试
    ├── 󰡯 hanoi
    ├──  hanoi.cpp  # 好玩的汉诺塔演示程序
    ├──  key_test.cpp  # 我做实验用的键盘按键序列测试
    ├──  Mouse_test.cpp  # 鼠标测试
    ├──  ncurses_test.cpp  # NCurses行为的测试
    ├──  rolling.cpp  # 另一个性能测试程序
    └──  test.out
```

### 构建方法

依赖: 类Unix系统, C++环境(支持C++20的编译器)

**编译**
```bash
make
```

**安装**
```bash
make install
```

**卸载**
```bash
make remove
```

**你可以在src/ezterm.cpp文件中最底部追加main函数, 然后编译成临时可执行程序**
```bash
make test
```

**清理构建过程中间文件**
```bash
make clear
```